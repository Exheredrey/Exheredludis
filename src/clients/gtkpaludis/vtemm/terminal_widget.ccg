/* vim: set sw=4 sts=4 et foldmethod=syntax : */

/*
 * Copyright (c) 2006 Piotr Rak
 *
 * This file is part of the Paludis package manager. Paludis is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * Paludis is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */
#include <vte/vte.h>

namespace
{

gboolean proxy_slot_selected_callback(VteTerminal * /* term */ , glong column, glong row, gpointer data)
{
    typedef Vte::Terminal::SlotIsSelected SlotType;
    SlotType& slot(*static_cast<SlotType*>(data));

    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    try
    {
    #endif //GLIBMM_EXCEPTIONS_ENABLED
        return slot(column, row);
    #ifdef GLIBMM_EXCEPTIONS_ENABLED
    }
    catch(...)
    {
        Glib::exception_handlers_invoke();
    }
    #endif //GLIBMM_EXCEPTIONS_ENABLED
    
    return 0;
}

} /* anonymous namespace */


namespace Vte
{

CharAttributes::CharAttributes(VteCharAttributes* obj) :
    _gobject(new VteCharAttributes(*obj))
{
}

CharAttributes::~CharAttributes()
{
    delete _gobject;
}

CharAttributes::CharAttributes(const CharAttributes& rhs) :
    _gobject(new VteCharAttributes(*rhs._gobject))
{
}

CharAttributes& CharAttributes::operator= (const CharAttributes& rhs)
{
    if (this != &rhs)
    {
        delete _gobject;
        _gobject = new VteCharAttributes(*rhs._gobject);
    }
    return *this;
}

int CharAttributes::row() const
{
    return _gobject->row;
}

int CharAttributes::column() const
{
    return _gobject->column;
}

Gdk::Color CharAttributes::foreground() const
{
    return Gdk::Color(&_gobject->fore, true);
}

Gdk::Color CharAttributes::background() const
{
    return Gdk::Color(&_gobject->back, true);
}

bool CharAttributes::underline() const
{
    return _gobject->underline;
}

bool CharAttributes::strikethrough() const
{
    return _gobject->strikethrough;
}

char* Terminal::get_text(const Terminal::SlotIsSelected& slot, std::vector<CharAttributes>& attributes)
{
    GArray* garray(g_array_new(false, true, sizeof(VteCharAttributes)));
    Terminal::SlotIsSelected slot_copy(slot);
    
    char * result(vte_terminal_get_text(gobj(), &proxy_slot_selected_callback, &slot_copy, garray));
    
    for (size_t i=0; i< garray->len; ++i)
    {
        attributes.push_back(new VteCharAttributes(g_array_index(garray, VteCharAttributes, i))); //TODO suboptimal deep copy
    }
    
    g_array_free(garray, false);
    
    return result;
}

char* Terminal::get_text_include_trailing_spaces(const Terminal::SlotIsSelected& slot, std::vector<CharAttributes>& attributes)
{
    GArray* garray(g_array_new(false, true, sizeof(VteCharAttributes)));
    Terminal::SlotIsSelected slot_copy(slot);
    
    char * result(vte_terminal_get_text_include_trailing_spaces(gobj(),
        &proxy_slot_selected_callback, &slot_copy, garray));
    
    for (size_t i=0; i< garray->len; ++i)
    {
        attributes.push_back(new VteCharAttributes(g_array_index(garray, VteCharAttributes, i))); //TODO suboptimal deep copy
    }

    g_array_free(garray, true);
    
    return result;
}

char* Terminal::get_text_range(long start_row, long start_col, long end_row, long end_col, const SlotIsSelected& slot, std::vector<CharAttributes>& attributes)
{
    GArray* garray(g_array_new(false, true, sizeof(VteCharAttributes)));
    Terminal::SlotIsSelected slot_copy(slot);
    
    char * result(vte_terminal_get_text_range(gobj(),start_row, start_col, end_row, end_col,
        &proxy_slot_selected_callback, &slot_copy, garray));
    
    for (size_t i=0; i< garray->len; ++i)
    {
        attributes.push_back(new VteCharAttributes(g_array_index(garray, VteCharAttributes, i))); //TODO suboptimal deep copy
    }
    
    g_array_free(garray, true);
    
    return result;
}

} /* namespace Vte */
