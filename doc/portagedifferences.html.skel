<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="en" xml:lang="en">
    <head>
        <title>Paludis, the Other Package Mangler</title>
        <link rel="stylesheet" href="paludis.css" type="text/css" />
    </head>
    <body>
@HEADER@

        <h1>Paludis, the Other Package Mangler</h1>

        <h2>How Paludis and Portage Differ</h2>

        <p>This is not a complete list. It's not even vaguely near complete. Rather, it's
        a collection of lists of things of interest that are intentionally different
        between Paludis and its predecessor, Portage.</p>

        <h3>For the End User</h3>

        <ul>

            <li>A whole different <a
                href="configuration.html">configuration system</a>, making it far easier to maintain
            multiple systems, some in chroots, with entirely separate configuration
            files.</li>

            <li>Performance. Paludis is <a
                href="http://ciaranm.org/show_post.pl?post_id=61">fast</a>.</li>

            <li>Low dependency bloat. No Python, no big external crypto libraries.</li>

            <li>Security integration (<code>paludis --pretend --install
                security</code>).</li>

            <li>Multiple repository support, replacing Portage's highly limited
            overlays.</li>

            <li>Support for repositories of different types (e.g. CRAN).</li>

            <li>Simple per-(category, package, version, anything else) environment variable
            setting (e.g. CFLAGS) without having to add on nasty external hacks.</li>

            <li>Licence filtering.</li>

            <li>Hook scripts, for running code after a certain action occurs.</li>

            <li>Wrappers for econf, emake, wget etc to allow user defined command bindings
            (nice, ionice, taskset etc).</li>

            <li>User definable package sets.</li>

            <li>Repositories can deliver news items, warning the user of important changes
            before they take place.</li>

            <li>Ability to sync from Subversion, Git, CVS etc.</li>

            <li>Ability to <a href="faq.html#removeunneeded">uninstall packages with dependencies</a>, and safely remove
            unused packages.</li>

            <li>Ability to see a report of insecure, unused etc packages affecting the
            system, either manually or automatically after a sync (<code>paludis
                --report</code>).</li>

            <li>Ability to <a href="faq.html#tree">see why a package is
                really being pulled in</a>, replacing Portage's
            misleading and incomplete tree support.</li>

            <li>Much more fine grained control over dropping dependencies.</li>

            <li>Ability to automatically reinstall scm (cvs, svn etc) packages after a
            given interval (<code>paludis --dl-reinstall-scm weekly</code>).</li>

            <li>Ability to <a href="faq.html#skipfirst">resume failed
                compiles</a> with far more control than is offered
            by Portage's limited <code>--resume</code> and
            <code>--skipfirst</code>.</li>

            <li>Ability to display additional information, such as USE flag
            descriptions, when installing a package.</li>

            <li>Secure installation and uninstallation of set*id files,
            preventing your system from being left vulnerable after having
            uninstalled or replaced an insecure application.</li>
        </ul>

        <h3>For the Ebuild Developer</h3>

        <p>As well as the end user advantages, ebuild authors will benefit from:</p>

        <ul>
            <li><code>:slot</code> dependencies</li>

            <li><code>::repository</code> dependencies</li>

            <li><code>[use]</code> dependencies</li>

            <li>Full and correct circular dependency detection</li>

            <li>Per package use masking, and from this per package use combination
            restrictions.</li>

            <li>Profile-level use forcing, globally and per-package, and from this the
            ability to specify a default in cases where one of n USE flags must be
            enabled.</li>

            <li>Default deep dependency resolution.</li>

            <li>Support for -scm, -try versions.</li>

            <li>Multiple inheritance for profiles.</li>

            <li>Ability to install hook scripts.</li>

            <li>Repository definable package sets.</li>

            <li>Ability to deliver news items to the end user.</li>

            <li>Ranged dep atom support.</li>

            <li>Extensive and easily extendable QA checks.</li>

            <li>Much more meaningful error messages, with proper context.</li>
        </ul>

        <h3>For the Programmer</h3>

        <ul>
            <li>Proper library / interface separation.</li>

            <li>Reasonable internals documentation, via Doxygen.</li>

            <li>Consistent interfaces for different repository types.</li>

            <li>Modularity where it matters.</li>

            <li>Test suites, to detect the impact of changes.</li>

            <li>Type safe interfaces, for detecting errors at compile time.</li>

            <li>A choice of programming language for external tools.</li>
        </ul>

@FOOTER@
    </body>
</html>

