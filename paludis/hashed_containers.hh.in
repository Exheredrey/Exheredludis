/* vim: set sw=4 sts=4 et foldmethod=syntax : */

@GENERATED_FILE@

/*
 * Copyright (c) 2006 Ciaran McCreesh <ciaranm@gentoo.org>
 *
 * This file is part of the Paludis package manager. Paludis is free software;
 * you can redistribute it and/or modify it under the terms of the GNU General
 * Public License version 2, as published by the Free Software Foundation.
 *
 * Paludis is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place, Suite 330, Boston, MA  02111-1307  USA
 */

#ifndef PALUDIS_GUARD_PALUDIS_HASHED_CONTAINERS_HH
#define PALUDIS_GUARD_PALUDIS_HASHED_CONTAINERS_HH 1

#define PALUDIS_HAVE_TR1_HASHES @HAVE_TR1_HASHES@
#define PALUDIS_HAVE_EXT_HASHES @HAVE_EXT_HASHES@

#include <paludis/qualified_package_name.hh>
#include <paludis/version_spec.hh>
#include <paludis/validated.hh>

#if PALUDIS_HAVE_TR1_HASHES
#  include <tr1/unordered_set>
#  include <tr1/unordered_map>
#elif PALUDIS_HAVE_EXT_HASHES
#  include <ext/hash_set>
#  include <ext/hash_map>
#else
#  include <set>
#  include <map>
#endif

#include <limits>
#include <string>
#include <functional>

namespace paludis
{
    template <typename T_>
    struct CRCHash;

    template <typename Key_, typename Value_>
    struct MakeHashedMap
    {
#if PALUDIS_HAVE_TR1_HASHES
        typedef std::tr1::unordered_map<Key_, Value_, CRCHash<Key_> > Type;
#elif PALUDIS_HAVE_EXT_HASHES
        typedef __gnu_cxx::hash_map<Key_, Value_, CRCHash<Key_> > Type;
#else
        typedef std::map<Key_, Value_> Type;
#endif
    };

    template <typename Key_>
    struct MakeHashedSet
    {
#if PALUDIS_HAVE_TR1_HASHES
        typedef std::tr1::unordered_set<Key_, CRCHash<Key_> > Type;
#elif PALUDIS_HAVE_EXT_HASHES
        typedef __gnu_cxx::hash_set<Key_, CRCHash<Key_> > Type;
#else
        typedef std::set<Key_> Type;
#endif
    };

#if PALUDIS_HAVE_TR1_HASHES || PALUDIS_HAVE_EXT_HASHES
    namespace
    {
        struct CRCHashBase
        {
            static const std::size_t h_shift = std::numeric_limits<std::size_t>::digits - 5;
            static const std::size_t h_mask = 0x1f << h_shift;
        };
    }

    template <>
    class CRCHash<QualifiedPackageName> :
        public std::unary_function<QualifiedPackageName, std::size_t>,
        protected CRCHashBase
    {
        public:
            std::size_t operator() (const QualifiedPackageName & val) const;
    };

    template <typename Validated_>
    class CRCHash<Validated<std::string, Validated_> > :
        public std::unary_function<Validated<std::string, Validated_>, std::size_t>,
        protected CRCHashBase
    {
        public:
            std::size_t operator() (const Validated<std::string, Validated_> & val) const;
    };

    template <>
    class CRCHash<std::pair<QualifiedPackageName, VersionSpec> > :
        public std::unary_function<std::pair<QualifiedPackageName, VersionSpec>, std::size_t>,
        protected CRCHashBase
    {
        public:
            std::size_t operator() (const std::pair<QualifiedPackageName, VersionSpec> & val) const;
    };

    template <typename Validated_>
    std::size_t
    CRCHash<Validated<std::string, Validated_> >::operator() (const Validated<std::string, Validated_> & val) const
    {
        const std::string & s1(val.data());
        std::size_t h(0);

        for (std::string::size_type t(0) ; t < s1.length() ; ++t)
        {
            std::size_t hh(h & h_mask);
            h <<= 5;
            h ^= (hh >> h_shift);
            h ^= s1[t];
        }

        return h;
    }

#endif

}

#endif
